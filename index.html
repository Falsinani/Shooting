<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<title>Barrier Blaster</title>

<meta name="viewport"
content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<style>
html, body {
  margin:0;
  padding:0;
  width:100%;
  height:100%;
  background:#0b1020;
  overflow:hidden;
  touch-action:none;
  overscroll-behavior:none;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
}

* {
  -webkit-touch-callout:none;
  -webkit-user-select:none;
  user-select:none;
}

canvas {
  width:100vw;
  height:100vh;
  display:block;
}
</style>
</head>

<body>
<canvas id="game"></canvas>

<script>
// ================== iOS SAFETY ==================
document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('dblclick', e => e.preventDefault(), { passive:false });

// ================== CANVAS ==================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let W, H, DPR;

function resize(){
  DPR = Math.min(2, window.devicePixelRatio || 1);
  W = innerWidth;
  H = innerHeight;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener("resize", resize);
resize();

// ================== AUDIO ==================
const bgMusic = new Audio(
  "https://cdn.pixabay.com/audio/2022/10/26/audio_48c7baf798.mp3"
);
bgMusic.loop = true;
bgMusic.volume = 0.35;
let musicStarted = false;

// ================== HAPTIC ==================
function haptic(ms=20){
  if (navigator.vibrate) navigator.vibrate(ms);
}

// ================== GAME STATE ==================
let last = performance.now();
let energy = 1;
let cooldown = 0;

const player = {
  x: W/2,
  y: H - 100,
  w: 40,
  h: 40
};

const bullets = [];
const barriers = [];
const particles = [];

let score = 0;
let spawnTimer = 0;

// ================== INPUT (DRAG) ==================
let dragging = false;
let lastX = 0;

canvas.addEventListener("pointerdown", e => {
  dragging = true;
  lastX = e.clientX;
  canvas.setPointerCapture(e.pointerId);

  if (!musicStarted){
    bgMusic.play().catch(()=>{});
    musicStarted = true;
  }
});

canvas.addEventListener("pointermove", e => {
  if (!dragging) return;
  const dx = e.clientX - lastX;
  lastX = e.clientX;

  player.x += dx * 1.4;
  player.x = Math.max(player.w/2+10, Math.min(W-player.w/2-10, player.x));
});

canvas.addEventListener("pointerup", ()=> dragging=false);
canvas.addEventListener("pointercancel", ()=> dragging=false);

// ================== HELPERS ==================
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const rnd = (a,b)=>a+Math.random()*(b-a);

// ================== GAME LOGIC ==================
function shoot(){
  if (cooldown>0 || energy<0.08) return;

  bullets.push({
    x: player.x,
    y: player.y - 20,
    r: 6,
    v: -800
  });

  energy -= 0.08;
  cooldown = 0.12;
  haptic(10);
}

function spawnBarrier(){
  barriers.push({
    x: rnd(30, W-80),
    y: -60,
    w: rnd(50,90),
    h: rnd(35,60),
    hp: 3
  });
}

function explode(x,y,power=1){
  haptic(40);
  for(let i=0;i<20*power;i++){
    particles.push({
      x,y,
      vx:rnd(-300,300),
      vy:rnd(-300,300),
      life:rnd(0.3,0.6)
    });
  }
}

function update(dt){
  energy = clamp(energy + dt*0.25, 0, 1);
  cooldown = Math.max(0, cooldown-dt);

  // AUTO FIRE
  shoot();

  spawnTimer -= dt;
  if (spawnTimer<=0){
    spawnBarrier();
    spawnTimer = 0.8;
  }

  bullets.forEach(b => b.y += b.v*dt);
  barriers.forEach(br => br.y += 150*dt);

  // COLLISIONS
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    for(let j=barriers.length-1;j>=0;j--){
      const br = barriers[j];
      if (
        b.x > br.x && b.x < br.x+br.w &&
        b.y > br.y && b.y < br.y+br.h
      ){
        bullets.splice(i,1);
        br.hp--;
        explode(b.x,b.y,0.6);
        if(br.hp<=0){
          explode(br.x+br.w/2, br.y+br.h/2,1.2);
          barriers.splice(j,1);
          score+=50;
        }
        break;
      }
    }
  }

  particles.forEach(p=>{
    p.life -= dt;
    p.x += p.vx*dt;
    p.y += p.vy*dt;
    p.vy += 400*dt;
  });

  // CLEANUP
  for(let i=particles.length-1;i>=0;i--)
    if(particles[i].life<=0) particles.splice(i,1);
}

// ================== DRAW ==================
function draw(){
  ctx.fillStyle="#0b1020";
  ctx.fillRect(0,0,W,H);

  // Player
  ctx.fillStyle="#7fffb2";
  ctx.beginPath();
  ctx.moveTo(player.x, player.y-player.h/2);
  ctx.lineTo(player.x+player.w/2, player.y+player.h/2);
  ctx.lineTo(player.x-player.w/2, player.y+player.h/2);
  ctx.closePath();
  ctx.fill();

  // Bullets
  ctx.fillStyle="#ffd27d";
  bullets.forEach(b=>{
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fill();
  });

  // Barriers
  barriers.forEach(br=>{
    ctx.fillStyle="rgba(255,255,255,0.12)";
    ctx.fillRect(br.x,br.y,br.w,br.h);
  });

  // Particles
  ctx.fillStyle="#ffb347";
  particles.forEach(p=>{
    ctx.globalAlpha=p.life*2;
    ctx.fillRect(p.x,p.y,4,4);
  });
  ctx.globalAlpha=1;
}

// ================== LOOP ==================
function loop(now){
  const dt = Math.min(0.033,(now-last)/1000);
  last=now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
